{"version":3,"sources":["../../src/repository/BaseEntity.ts"],"names":[],"mappings":";;;AACA,kCAAsE;AAWtE,mDAAgD;AAIhD;;GAEG;AACH;IAAA;IAyaA,CAAC;IA7ZG,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E;;;OAGG;IACH,0BAAK,GAAL;QACI,OAAQ,IAAI,CAAC,WAAmB,CAAC,aAAa,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IACjE,CAAC;IAED;;;OAGG;IACH,yBAAI,GAAJ;QACI,OAAQ,IAAI,CAAC,WAAmB,CAAC,aAAa,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAChE,CAAC;IAED;;OAEG;IACH,2BAAM,GAAN;QACI,OAAQ,IAAI,CAAC,WAAmB,CAAC,aAAa,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAClE,CAAC;IAED;;OAEG;IACG,2BAAM,GAAZ;;;;;;wBACU,IAAI,GAAQ,IAAI,CAAC,WAAW,CAAC;wBACF,qBAAM,IAAI,CAAC,aAAa,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAA;;wBAArF,YAAY,GAAe,SAA0D;wBAE3F,yBAAW,CAAC,MAAM,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;;;;;KAC1C;IAED,4EAA4E;IAC5E,wBAAwB;IACxB,4EAA4E;IAE5E;;OAEG;IACI,wBAAa,GAApB,UAAqB,UAAsB;QACvC,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC;IACrC,CAAC;IAED;;OAEG;IACI,wBAAa,GAApB;QACI,IAAM,UAAU,GAAgB,IAAY,CAAC,cAAc,IAAI,qBAAa,EAAE,CAAC;QAC/E,OAAO,UAAU,CAAC,aAAa,CAAI,IAAI,CAAC,CAAC;IAC7C,CAAC;IAOD,sBAAW,oBAAM;QALjB;;;;WAIG;aACH;YACI,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,MAAM,CAAC;QACvC,CAAC;;;OAAA;IAED;;;OAGG;IACI,gBAAK,GAAZ,UAAa,MAAkB;QAC3B,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IAC9C,CAAC;IAED;;OAEG;IACI,gBAAK,GAAZ,UAAwD,MAAS;QAC7D,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IACvD,CAAC;IAED;;OAEG;IACI,6BAAkB,GAAzB,UAAqE,KAAc;QAC/E,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;IACnE,CAAC;IAkBF;;;QAGI;IACI,iBAAM,GAAb,UAAyD,gBAAsB;QAC3E,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;IAClE,CAAC;IAED;;OAEG;IACI,gBAAK,GAAZ,UAAwD,eAAkB;QAAE,qBAAgC;aAAhC,UAAgC,EAAhC,qBAAgC,EAAhC,IAAgC;YAAhC,oCAAgC;;;QACxG,OAAO,CAAA,KAAC,IAAY,CAAC,aAAa,EAAE,CAAA,CAAC,KAAK,6BAAC,eAAe,GAAK,WAAW,GAAE;IAChF,CAAC;IAED;;;;;;;;OAQG;IACI,kBAAO,GAAd,UAA0D,UAA0B;QAChF,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IAC7D,CAAC;IAcD;;OAEG;IACI,eAAI,GAAX,UAAuD,gBAAuB,EAAE,OAAqB;QACjG,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,IAAI,CAAC,gBAAuB,EAAE,OAAO,CAAC,CAAC;IAChF,CAAC;IAYD;;OAEG;IACI,iBAAM,GAAb,UAAyD,gBAAuB,EAAE,OAAuB;QACrG,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,MAAM,CAAC,gBAAuB,EAAE,OAAO,CAAC,CAAC;IAClF,CAAC;IAED;;;;;OAKG;IACI,iBAAM,GAAb,UAAyD,MAA6D,EAAE,OAAqB;QACzI,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IACjE,CAAC;IAED;;;;;OAKG;IACI,iBAAM,GAAb,UAAyD,QAA6F,EAAE,aAAwC,EAAE,OAAqB;QACnN,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,MAAM,CAAC,QAAQ,EAAE,aAAa,EAAE,OAAO,CAAC,CAAC;IAClF,CAAC;IAED;;;;;OAKG;IACI,iBAAM,GAAb,UAAyD,QAA6F,EAAE,OAAuB;QAC3K,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IACnE,CAAC;IAYD;;OAEG;IACI,gBAAK,GAAZ,UAAwD,mBAAwD;QAC5G,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,KAAK,CAAC,mBAA0B,CAAC,CAAC;IAC3E,CAAC;IAYD;;OAEG;IACI,eAAI,GAAX,UAAuD,mBAAwD;QAC3G,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,IAAI,CAAC,mBAA0B,CAAC,CAAC;IAC1E,CAAC;IAgBD;;;;OAIG;IACI,uBAAY,GAAnB,UAA+D,mBAAwD;QACnH,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,YAAY,CAAC,mBAA0B,CAAC,CAAC;IAClF,CAAC;IAcD;;;OAGG;IACI,oBAAS,GAAhB,UAA4D,GAAU,EAAE,mBAAwD;QAC5H,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,SAAS,CAAC,GAAG,EAAE,mBAA0B,CAAC,CAAC;IACpF,CAAC;IAiBD;;OAEG;IACI,kBAAO,GAAd,UAA0D,mBAAoF,EAAE,YAA6B;QACzK,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,OAAO,CAAC,mBAA0B,EAAE,YAAY,CAAC,CAAC;IAC3F,CAAC;IAiBD;;OAEG;IACI,wBAAa,GAApB,UAAgE,mBAAoF,EAAE,YAA6B;QAC/K,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,aAAa,CAAC,mBAA0B,EAAE,YAAY,CAAC,CAAC;IACjG,CAAC;IAcD;;;OAGG;IACI,kBAAO,GAAd,UAAuB,mBAAkE;QACrF,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,OAAO,CAAC,mBAA0B,CAAC,CAAC;IAC7E,CAAC;IAcD;;;OAGG;IACI,8BAAmB,GAA1B,UAAmC,mBAAkE;QACjG,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,mBAAmB,CAAC,mBAA0B,CAAC,CAAC;IACzF,CAAC;IAcD;;;OAGG;IACI,qBAAU,GAAjB,UAA0B,mBAAkE;QACxF,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,UAAU,CAAC,mBAA0B,CAAC,CAAC;IAChF,CAAC;IAcD;;;OAGG;IACI,uBAAY,GAAnB,UAA4B,mBAAkE;QAC1F,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,YAAY,CAAC,mBAA0B,CAAC,CAAC;IAClF,CAAC;IAED;;;OAGG;IACI,gBAAK,GAAZ,UAAwD,KAAa,EAAE,UAAkB;QACrF,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,KAAK,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;IAClE,CAAC;IAED;;OAEG;IACI,gBAAK,GAAZ;QACI,OAAQ,IAAY,CAAC,aAAa,EAAE,CAAC,KAAK,EAAE,CAAC;IACjD,CAAC;IAEL,iBAAC;AAAD,CAzaA,AAyaC,IAAA;AAzaY,gCAAU","file":"BaseEntity.js","sourcesContent":["import {Repository} from \"./Repository\";\nimport {FindOptions, FindOptionsWhere, getConnection} from \"../index\";\nimport {DeepPartial} from \"../common/DeepPartial\";\nimport {ObjectType} from \"../common/ObjectType\";\nimport {Connection} from \"../connection/Connection\";\nimport {ObjectID} from \"../driver/mongodb/typings\";\nimport {DeleteResult} from \"../query-builder/result/DeleteResult\";\nimport {InsertResult} from \"../query-builder/result/InsertResult\";\nimport {UpdateResult} from \"../query-builder/result/UpdateResult\";\nimport {SelectQueryBuilder} from \"../query-builder/SelectQueryBuilder\";\nimport {RemoveOptions} from \"./RemoveOptions\";\nimport {SaveOptions} from \"./SaveOptions\";\nimport {ObjectUtils} from \"../util/ObjectUtils\";\nimport {QueryDeepPartialEntity} from \"../query-builder/QueryPartialEntity\";\nimport * as Observable from \"zen-observable\";\n\n/**\n * Base abstract entity for all entities, used in ActiveRecord patterns.\n */\nexport class BaseEntity {\n\n    // -------------------------------------------------------------------------\n    // Private Static Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used in all static methods of the BaseEntity.\n     */\n    // @ts-ignore: Unused variable which is actually used\n    private static usedConnection?: Connection;\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if entity has an id.\n     * If entity composite compose ids, it will check them all.\n     */\n    hasId(): boolean {\n        return (this.constructor as any).getRepository().hasId(this);\n    }\n\n    /**\n     * Saves current entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save(): Promise<this> {\n        return (this.constructor as any).getRepository().save(this);\n    }\n\n    /**\n     * Removes current entity from the database.\n     */\n    remove(): Promise<this> {\n        return (this.constructor as any).getRepository().remove(this);\n    }\n\n    /**\n     * Reloads entity data from the database.\n     */\n    async reload(): Promise<void> {\n        const base: any = this.constructor;\n        const newestEntity: BaseEntity = await base.getRepository().findOneOrFail(base.getId(this));\n\n        ObjectUtils.assign(this, newestEntity);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sets connection to be used by entity.\n     */\n    static useConnection(connection: Connection) {\n        this.usedConnection = connection;\n    }\n\n    /**\n     * Gets current entity's Repository.\n     */\n    static getRepository<T extends BaseEntity>(this: ObjectType<T>): Repository<T> {\n        const connection: Connection = (this as any).usedConnection || getConnection();\n        return connection.getRepository<T>(this);\n    }\n\n    /**\n     * Returns object that is managed by this repository.\n     * If this repository manages entity from schema,\n     * then it returns a name of that schema instead.\n     */\n    static get target(): Function|string {\n        return this.getRepository().target;\n    }\n\n    /**\n     * Checks entity has an id.\n     * If entity composite compose ids, it will check them all.\n     */\n    static hasId(entity: BaseEntity): boolean {\n        return this.getRepository().hasId(entity);\n    }\n\n    /**\n     * Gets entity mixed id.\n     */\n    static getId<T extends BaseEntity>(this: ObjectType<T>, entity: T): any {\n        return (this as any).getRepository().getId(entity);\n    }\n\n    /**\n     * Creates a new query builder that can be used to build a sql query.\n     */\n    static createQueryBuilder<T extends BaseEntity>(this: ObjectType<T>, alias?: string): SelectQueryBuilder<T> {\n        return (this as any).getRepository().createQueryBuilder(alias);\n    }\n\n    /**\n     * Creates a new entity instance.\n     */\n    static create<T extends BaseEntity>(this: ObjectType<T>): T;\n\n    /**\n     * Creates a new entities and copies all entity properties from given objects into their new entities.\n     * Note that it copies only properties that present in entity schema.\n     */\n    static create<T extends BaseEntity>(this: ObjectType<T>, entityLikeArray: DeepPartial<T>[]): T;\n\n    /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that present in entity schema.\n     */\n    static create<T extends BaseEntity>(this: ObjectType<T>, entityLike: DeepPartial<T>): T;\n   /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that present in entity schema.\n     */\n    static create<T extends BaseEntity>(this: ObjectType<T>, entityOrEntities?: any): T {\n        return (this as any).getRepository().create(entityOrEntities);\n    }\n\n    /**\n     * Merges multiple entities (or entity-like objects) into a given entity.\n     */\n    static merge<T extends BaseEntity>(this: ObjectType<T>, mergeIntoEntity: T, ...entityLikes: DeepPartial<T>[]): T {\n        return (this as any).getRepository().merge(mergeIntoEntity, ...entityLikes);\n    }\n\n    /**\n     * Creates a new entity from the given plan javascript object. If entity already exist in the database, then\n     * it loads it (and everything related to it), replaces all values with the new ones from the given object\n     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n     * replaced from the new object.\n     *\n     * Note that given entity-like object must have an entity id / primary key to find entity by.\n     * Returns undefined if entity with given id was not found.\n     */\n    static preload<T extends BaseEntity>(this: ObjectType<T>, entityLike: DeepPartial<T>): Promise<T|undefined> {\n        return (this as any).getRepository().preload(entityLike);\n    }\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    static save<T extends BaseEntity>(this: ObjectType<T>, entities: T[], options?: SaveOptions): Promise<T[]>;\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    static save<T extends BaseEntity>(this: ObjectType<T>, entity: T, options?: SaveOptions): Promise<T>;\n\n    /**\n     * Saves one or many given entities.\n     */\n    static save<T extends BaseEntity>(this: ObjectType<T>, entityOrEntities: T|T[], options?: SaveOptions): Promise<T|T[]> {\n        return (this as any).getRepository().save(entityOrEntities as any, options);\n    }\n\n    /**\n     * Removes a given entities from the database.\n     */\n    static remove<T extends BaseEntity>(this: ObjectType<T>, entities: T[], options?: RemoveOptions): Promise<T[]>;\n\n    /**\n     * Removes a given entity from the database.\n     */\n    static remove<T extends BaseEntity>(this: ObjectType<T>, entity: T, options?: RemoveOptions): Promise<T>;\n\n    /**\n     * Removes one or many given entities.\n     */\n    static remove<T extends BaseEntity>(this: ObjectType<T>, entityOrEntities: T|T[], options?: RemoveOptions): Promise<T|T[]> {\n        return (this as any).getRepository().remove(entityOrEntities as any, options);\n    }\n\n    /**\n     * Inserts a given entity into the database.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT query.\n     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n     */\n    static insert<T extends BaseEntity>(this: ObjectType<T>, entity: QueryDeepPartialEntity<T>|QueryDeepPartialEntity<T>[], options?: SaveOptions): Promise<InsertResult> {\n        return (this as any).getRepository().insert(entity, options);\n    }\n\n    /**\n     * Updates entity partially. Entity can be found by a given conditions.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient UPDATE query.\n     * Does not check if entity exist in the database.\n     */\n    static update<T extends BaseEntity>(this: ObjectType<T>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|FindOptionsWhere<T>, partialEntity: QueryDeepPartialEntity<T>, options?: SaveOptions): Promise<UpdateResult> {\n        return (this as any).getRepository().update(criteria, partialEntity, options);\n    }\n\n    /**\n     * Deletes entities by a given criteria.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     */\n    static delete<T extends BaseEntity>(this: ObjectType<T>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|FindOptionsWhere<T>, options?: RemoveOptions): Promise<DeleteResult> {\n        return (this as any).getRepository().delete(criteria, options);\n    }\n\n    /**\n     * Counts entities that match given options.\n     */\n    static count<T extends BaseEntity>(this: ObjectType<T>, options?: FindOptionsWhere<T>): Promise<number>;\n\n    /**\n     * Counts entities that match given conditions.\n     */\n    static count<T extends BaseEntity>(this: ObjectType<T>, conditions?: FindOptions<T>): Promise<number>;\n\n    /**\n     * Counts entities that match given find options or conditions.\n     */\n    static count<T extends BaseEntity>(this: ObjectType<T>, optionsOrConditions?: FindOptions<T>|FindOptionsWhere<T>): Promise<number> {\n        return (this as any).getRepository().count(optionsOrConditions as any);\n    }\n\n    /**\n     * Finds entities that match given options.\n     */\n    static find<T extends BaseEntity>(this: ObjectType<T>, options?: FindOptions<T>): Promise<T[]>;\n\n    /**\n     * Finds entities that match given conditions.\n     */\n    static find<T extends BaseEntity>(this: ObjectType<T>, conditions?: FindOptionsWhere<T>): Promise<T[]>;\n\n    /**\n     * Finds entities that match given find options or conditions.\n     */\n    static find<T extends BaseEntity>(this: ObjectType<T>, optionsOrConditions?: FindOptions<T>|FindOptionsWhere<T>): Promise<T[]> {\n        return (this as any).getRepository().find(optionsOrConditions as any);\n    }\n\n    /**\n     * Finds entities that match given find options.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    static findAndCount<T extends BaseEntity>(this: ObjectType<T>, options?: FindOptions<T>): Promise<[ T[], number ]>;\n\n    /**\n     * Finds entities that match given conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    static findAndCount<T extends BaseEntity>(this: ObjectType<T>, conditions?: FindOptionsWhere<T>): Promise<[ T[], number ]>;\n\n    /**\n     * Finds entities that match given find options or conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    static findAndCount<T extends BaseEntity>(this: ObjectType<T>, optionsOrConditions?: FindOptions<T>|FindOptionsWhere<T>): Promise<[ T[], number ]> {\n        return (this as any).getRepository().findAndCount(optionsOrConditions as any);\n    }\n\n    /**\n     * Finds entities by ids.\n     * Optionally find options can be applied.\n     */\n    static findByIds<T extends BaseEntity>(this: ObjectType<T>, ids: any[], options?: FindOptions<T>): Promise<T[]>;\n\n    /**\n     * Finds entities by ids.\n     * Optionally conditions can be applied.\n     */\n    static findByIds<T extends BaseEntity>(this: ObjectType<T>, ids: any[], conditions?: FindOptionsWhere<T>): Promise<T[]>;\n\n    /**\n     * Finds entities by ids.\n     * Optionally find options can be applied.\n     */\n    static findByIds<T extends BaseEntity>(this: ObjectType<T>, ids: any[], optionsOrConditions?: FindOptions<T>|FindOptionsWhere<T>): Promise<T[]> {\n        return (this as any).getRepository().findByIds(ids, optionsOrConditions as any);\n    }\n\n    /**\n     * Finds first entity that matches given options.\n     */\n    static findOne<T extends BaseEntity>(this: ObjectType<T>, id?: string|number|Date|ObjectID, options?: FindOptions<T>): Promise<T|undefined>;\n\n    /**\n     * Finds first entity that matches given options.\n     */\n    static findOne<T extends BaseEntity>(this: ObjectType<T>, options?: FindOptions<T>): Promise<T|undefined>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOne<T extends BaseEntity>(this: ObjectType<T>, conditions?: FindOptionsWhere<T>, options?: FindOptions<T>): Promise<T|undefined>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOne<T extends BaseEntity>(this: ObjectType<T>, optionsOrConditions?: string|number|Date|ObjectID|FindOptions<T>|FindOptionsWhere<T>, maybeOptions?: FindOptions<T>): Promise<T|undefined> {\n        return (this as any).getRepository().findOne(optionsOrConditions as any, maybeOptions);\n    }\n\n    /**\n     * Finds first entity that matches given options.\n     */\n    static findOneOrFail<T extends BaseEntity>(this: ObjectType<T>, id?: string|number|Date|ObjectID, options?: FindOptions<T>): Promise<T>;\n\n    /**\n     * Finds first entity that matches given options.\n     */\n    static findOneOrFail<T extends BaseEntity>(this: ObjectType<T>, options?: FindOptions<T>): Promise<T>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOneOrFail<T extends BaseEntity>(this: ObjectType<T>, conditions?: FindOptionsWhere<T>, options?: FindOptions<T>): Promise<T>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOneOrFail<T extends BaseEntity>(this: ObjectType<T>, optionsOrConditions?: string|number|Date|ObjectID|FindOptions<T>|FindOptionsWhere<T>, maybeOptions?: FindOptions<T>): Promise<T> {\n        return (this as any).getRepository().findOneOrFail(optionsOrConditions as any, maybeOptions);\n    }\n\n    /**\n     * Finds entities that match given options and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observe<Entity>(options?: FindOptions<Entity>): Observable<Entity[]>;\n\n    /**\n     * Finds entities that match given conditions and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observe<Entity>(conditions?: FindOptionsWhere<Entity>): Observable<Entity[]>;\n\n    /**\n     * Finds entities that match given options and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observe<Entity>(optionsOrConditions?: FindOptions<Entity>|FindOptionsWhere<Entity>): Observable<Entity[]> {\n        return (this as any).getRepository().observe(optionsOrConditions as any);\n    }\n\n    /**\n     * Finds entities and count that match given options and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observeManyAndCount<Entity>(options?: FindOptions<Entity>): Observable<[Entity[], number]>;\n\n    /**\n     * Finds entities and count that match given conditions and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observeManyAndCount<Entity>(conditions?: FindOptionsWhere<Entity>): Observable<[Entity[], number]>;\n\n    /**\n     * Finds entities and count that match given options and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observeManyAndCount<Entity>(optionsOrConditions?: FindOptions<Entity>|FindOptionsWhere<Entity>): Observable<[Entity[], number]> {\n        return (this as any).getRepository().observeManyAndCount(optionsOrConditions as any);\n    }\n\n    /**\n     * Finds entity that match given options and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observeOne<Entity>(options?: FindOptions<Entity>): Observable<Entity>;\n\n    /**\n     * Finds entity that match given conditions and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observeOne<Entity>(conditions?: FindOptionsWhere<Entity>): Observable<Entity>;\n\n    /**\n     * Finds entity that match given options and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observeOne<Entity>(optionsOrConditions?: FindOptions<Entity>|FindOptionsWhere<Entity>): Observable<Entity> {\n        return (this as any).getRepository().observeOne(optionsOrConditions as any);\n    }\n\n    /**\n     * Gets the entities count match given options and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observeCount<Entity>(options?: FindOptions<Entity>): Observable<number>;\n\n    /**\n     * Gets the entities count match given options and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observeCount<Entity>(conditions?: FindOptionsWhere<Entity>): Observable<number>;\n\n    /**\n     * Gets the entities count match given options and returns observable.\n     * Whenever new data appears that matches given query observable emits new value.\n     */\n    static observeCount<Entity>(optionsOrConditions?: FindOptions<Entity>|FindOptionsWhere<Entity>): Observable<number> {\n        return (this as any).getRepository().observeCount(optionsOrConditions as any);\n    }\n\n    /**\n     * Executes a raw SQL query and returns a raw database results.\n     * Raw query execution is supported only by relational databases (MongoDB is not supported).\n     */\n    static query<T extends BaseEntity>(this: ObjectType<T>, query: string, parameters?: any[]): Promise<any> {\n        return (this as any).getRepository().query(query, parameters);\n    }\n\n    /**\n     * Clears all the data from the given table/collection (truncates/drops it).\n     */\n    static clear<T extends BaseEntity>(this: ObjectType<T>, ): Promise<void> {\n        return (this as any).getRepository().clear();\n    }\n\n}\n"],"sourceRoot":".."}