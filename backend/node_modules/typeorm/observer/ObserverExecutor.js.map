{"version":3,"sources":["../../src/observer/ObserverExecutor.ts"],"names":[],"mappings":"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","file":"ObserverExecutor.js","sourcesContent":["import {EntityMetadata, ObjectLiteral} from \"..\";\nimport {Subject} from \"../persistence/Subject\";\nimport {SubjectChangedColumnsComputer} from \"../persistence/SubjectChangedColumnsComputer\";\nimport {QueryObserver} from \"./QueryObserver\";\n\n/**\n * Executes all given observers.\n */\nexport class ObserverExecutor {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private observers: QueryObserver[]) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes given observers.\n     */\n    async execute(): Promise<void> {\n        for (let observer of this.observers) {\n\n            if (observer.insertEvents.length > 0) {\n                await this.handleInsertEvent(observer);\n                observer.insertEvents = [];\n            }\n\n            if (observer.updateEvents.length > 0) {\n                await this.handleUpdateEvent(observer);\n                observer.updateEvents = [];\n            }\n\n            if (observer.removeEvents.length > 0) {\n                await this.handleRemoveEvent(observer);\n                observer.removeEvents = [];\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private async handleInsertEvent(observer: QueryObserver) {\n\n        // if something new is inserted - we never know if that matches original query\n        // so we execute query again and emit event if we find something new\n        if (observer.type === \"find\") {\n            await observer.connection.manager.find(observer.metadata.target as any, observer.options as any).then(entities => {\n                const newEntities = this.findInserted(observer.metadata, entities, observer.lastEmitEntities);\n                if (newEntities) {\n                    observer.lastEmitEntities = newEntities;\n                    observer.subscriptionObserver.next(observer.lastEmitEntities);\n                }\n            });\n\n        } else if (observer.type === \"findOne\") {\n            await observer.connection.manager.findOne(observer.metadata.target as any, observer.options as any).then(entity => {\n                if (!entity || !observer.lastEmitEntity) {\n                    if (entity === undefined && observer.lastEmitEntity === undefined) {\n                        return;\n                    }\n                    observer.lastEmitEntity = entity;\n                    observer.subscriptionObserver.next(observer.lastEmitEntity);\n                    return;\n                }\n                const newEntities = this.findInserted(observer.metadata, [entity], [observer.lastEmitEntity]);\n                if (newEntities) {\n                    observer.lastEmitEntity = newEntities[0];\n                    observer.subscriptionObserver.next(observer.lastEmitEntity);\n                }\n            });\n\n        } else if (observer.type === \"findAndCount\") {\n            await observer.connection.manager.findAndCount(observer.metadata.target as any, observer.options as any).then(([entities, count]) => {\n                const newEntities = this.findInserted(observer.metadata, entities, observer.lastEmitEntities);\n                if (newEntities || count !== observer.lastEmitCount) {\n                    if (newEntities)\n                        observer.lastEmitEntities = newEntities;\n                    if (count !== observer.lastEmitCount)\n                        observer.lastEmitCount = count;\n\n                    observer.subscriptionObserver.next([observer.lastEmitEntities, observer.lastEmitCount]);\n                }\n            });\n\n        } else if (observer.type === \"count\") {\n            await observer.connection.manager.count(observer.metadata.target as any, observer.options as any, { observers: false }).then(count => {\n                if (count !== observer.lastEmitCount) {\n                    observer.lastEmitCount = count;\n                    observer.subscriptionObserver.next(observer.lastEmitCount);\n                }\n            });\n        }\n    }\n\n    private findInserted(metadata: EntityMetadata, entities: ObjectLiteral[], lastEmitEntities: ObjectLiteral[]) {\n\n        // to make sure we won't have instance mess we try to return array of NEW entities\n        // in the same NEW order we have, but with OLD instances that we can find in the\n        let hasChange = false;\n        entities = entities.map(entity => {\n            const sameEntityInPrevious = lastEmitEntities.find(previousEntity => {\n                return metadata.compareEntities(entity, previousEntity);\n            });\n            if (sameEntityInPrevious) {\n                return sameEntityInPrevious;\n            } else {\n                hasChange = true;\n                return entity;\n            }\n        });\n\n        // if we have any new entity emit a new event\n        if (hasChange)\n            return entities;\n\n        return undefined;\n    }\n\n    private async handleUpdateEvent(observer: QueryObserver) {\n\n        // if something is updated - we check if its any entity of the queried entities\n        // and if it is, we compare properties to understand if something was changed\n        // and emit event if something was\n        const events = observer.updateEvents;\n        const hasEntities = events.every(event => {\n            return event.entity && observer.metadata.hasId(event.entity);\n        });\n        if (hasEntities && observer.type !== \"count\") {\n            const hasAnyEntityChanges = events.some(event => this.hasChanges(observer, event.entity));\n            if (hasAnyEntityChanges === false)\n                return;\n        }\n\n        if (observer.type === \"find\") {\n            await observer.connection.manager\n                .find(observer.metadata.target as any, observer.options as any)\n                .then(entities => {\n                    const hasChanges = entities.some(entity => this.hasChanges(observer, entity));\n                    if (hasChanges || entities.length !== observer.lastEmitEntities.length) {\n                        observer.lastEmitEntities = entities;\n                        observer.subscriptionObserver.next(observer.lastEmitEntities);\n                    }\n                });\n\n        } else if (observer.type === \"findOne\") {\n            await observer.connection.manager\n                .findOne(observer.metadata.target as any, observer.options as any)\n                .then(entity => {\n                    if (!entity) {\n                        observer.lastEmitEntity = undefined;\n                        observer.subscriptionObserver.next(observer.lastEmitEntity);\n                    } else if (this.hasChanges(observer, entity)) {\n                        observer.lastEmitEntity = entity;\n                        observer.subscriptionObserver.next(observer.lastEmitEntity);\n                    }\n                });\n\n        } else if (observer.type === \"findAndCount\") {\n            await observer.connection.manager\n                .findAndCount(observer.metadata.target as any, observer.options as any)\n                .then(([entities, count]) => {\n\n                    const hasChanges = entities.some(entity => this.hasChanges(observer, entity));\n                    if (hasChanges || count !== observer.lastEmitCount || entities.length !== observer.lastEmitEntities.length) {\n                        if (hasChanges || entities.length !== observer.lastEmitEntities.length)\n                            observer.lastEmitEntities = entities;\n                        if (count !== observer.lastEmitCount)\n                            observer.lastEmitCount = count;\n\n                        observer.subscriptionObserver.next([observer.lastEmitEntities, observer.lastEmitCount]);\n                    }\n                });\n        } else if (observer.type === \"count\") {\n            await observer.connection.manager\n                .count(observer.metadata.target as any, observer.options as any)\n                .then(count => {\n                    if (count !== observer.lastEmitCount) {\n                        observer.lastEmitCount = count;\n                        observer.subscriptionObserver.next(observer.lastEmitCount);\n                    }\n                });\n        }\n    }\n\n    private hasChanges(observer: QueryObserver, entity: ObjectLiteral) {\n\n        let previousEntity: ObjectLiteral|undefined;\n        if (observer.type === \"find\" || observer.type === \"findAndCount\") {\n            previousEntity = observer.lastEmitEntities.find(previousEntity => {\n                return observer.metadata.compareEntities(previousEntity, entity);\n            });\n        } else if (observer.type === \"findOne\") {\n            previousEntity = observer.lastEmitEntity;\n        }\n\n        // if previous entity is not set it probably means it was failed off the condition first,\n        // then update causes it to match the condition\n        if (!previousEntity)\n            return true;\n\n        const subject = new Subject({\n            metadata: observer.metadata,\n            entity: entity,\n            databaseEntity: previousEntity,\n        });\n\n        // find changed columns - if we have them\n        new SubjectChangedColumnsComputer().compute([subject]);\n        return subject.changeMaps.length > 0;\n    }\n\n    private async handleRemoveEvent(observer: QueryObserver) {\n\n        // if something is removed we have to check:\n        // - if entity with id was removed we check if its that entity\n        // - if entity by query was removed we do execute original query again and differ\n\n        const events = observer.removeEvents;\n        const allEntities = events.every(event => event.entityId);\n        if (allEntities && observer.type !== \"count\") {\n            events.forEach(event => {\n                if (observer.type === \"find\") {\n                    const findPreviousEntity = observer.lastEmitEntities.find(entity => {\n                        return observer.metadata.compareEntities(entity, observer.metadata.ensureEntityIdMap(event.entityId));\n                    });\n                    if (findPreviousEntity) {\n                        observer.lastEmitEntities.splice(observer.lastEmitEntities.indexOf(findPreviousEntity), 1);\n                        observer.subscriptionObserver.next(observer.lastEmitEntities);\n                    }\n\n                } else if (observer.type === \"findAndCount\") {\n                    const findAndCountPreviousEntity = observer.lastEmitEntities.find(entity => {\n                        return observer.metadata.compareEntities(entity, observer.metadata.ensureEntityIdMap(event.entityId));\n                    });\n                    if (findAndCountPreviousEntity) {\n                        observer.lastEmitEntities.splice(observer.lastEmitEntities.indexOf(findAndCountPreviousEntity), 1);\n                        observer.lastEmitCount--;\n                        observer.subscriptionObserver.next([observer.lastEmitEntities, observer.lastEmitCount]);\n\n                    }\n\n                } else if (observer.type === \"findOne\") {\n                    if (observer.lastEmitEntity) {\n                        if (observer.metadata.compareEntities(observer.lastEmitEntity, observer.metadata.ensureEntityIdMap(event.entityId))) {\n                            observer.lastEmitEntity = undefined;\n                            observer.subscriptionObserver.next(observer.lastEmitEntity);\n                        }\n                    }\n                }\n            });\n            return;\n\n        } else {\n\n            if (observer.type === \"find\") {\n                if (!observer.lastEmitEntities.length && !observer.lastEmitCount)\n                    return;\n\n                await observer.connection.manager.find(observer.metadata.target as any, observer.options as any).then(entities => {\n\n                    // if we have any new entity emit a new event\n                    if (this.hasRemoved(observer, entities)) {\n                        observer.lastEmitEntities = entities;\n                        observer.subscriptionObserver.next(observer.lastEmitEntities);\n                    }\n                });\n\n            } else if (observer.type === \"findAndCount\") {\n                if (!observer.lastEmitEntities.length && !observer.lastEmitCount)\n                    return;\n\n                await observer.connection.manager.findAndCount(observer.metadata.target as any, observer.options as any).then(([entities, count]) => {\n\n                    // if we have any new entity emit a new event\n                    if (this.hasRemoved(observer, entities) || observer.lastEmitCount !== count) {\n                        observer.lastEmitEntities = entities;\n                        observer.lastEmitCount = count;\n                        observer.subscriptionObserver.next([observer.lastEmitEntities, observer.lastEmitCount]);\n                    }\n                });\n\n            } else if (observer.type === \"findOne\") {\n                if (!observer.lastEmitEntity)\n                    return;\n\n                await observer.connection.manager.findOne(observer.metadata.target as any, observer.options as any).then(entity => {\n                    if (!entity) {\n                        observer.lastEmitEntity = undefined;\n                        observer.subscriptionObserver.next(observer.lastEmitEntity);\n                        return;\n                    }\n\n                    // if we have any new entity emit a new event\n                    if (this.hasRemoved(observer, [entity])) {\n                        observer.lastEmitEntity = undefined;\n                        observer.subscriptionObserver.next(observer.lastEmitEntity);\n                    }\n                });\n\n            } else if (observer.type === \"count\") {\n                if (!observer.lastEmitCount)\n                    return;\n\n                await observer.connection.manager.count(observer.metadata.target as any, observer.options as any, { observers: false }).then(count => {\n                    if (observer.lastEmitCount !== count) {\n                        observer.lastEmitCount = count;\n                        observer.subscriptionObserver.next(observer.lastEmitCount);\n                    }\n                });\n            }\n\n        }\n    }\n\n    private hasRemoved(observer: QueryObserver, entities: ObjectLiteral[]) {\n        let hasChange = false;\n\n        if (observer.type === \"find\" || observer.type === \"findAndCount\") {\n            observer.lastEmitEntities.forEach(previousEntity => {\n                const entity = entities.find(entity => {\n                    return observer.metadata.compareEntities(previousEntity, entity);\n                });\n\n                if (!entity) {\n                    hasChange = true;\n                    observer.lastEmitEntities.splice(observer.lastEmitEntities.indexOf(previousEntity), 1);\n                }\n            });\n        } else if (observer.type === \"findOne\") {\n            if (!observer.lastEmitEntity)\n                return false;\n\n            const entity = entities.find(entity => {\n                return observer.metadata.compareEntities(observer.lastEmitEntity!, entity);\n            });\n            if (!entity)\n                return false;\n        }\n\n        return hasChange;\n    }\n\n}\n"],"sourceRoot":".."}